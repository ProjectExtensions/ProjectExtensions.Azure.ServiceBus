{"name":"Projectextensions.azure.servicebus","tagline":"ProjectExtensions.Azure.ServiceBus","body":"#ProjectExtensions.Azure.ServiceBus\r\n\r\nAn easier way to work with the Azure service bus.\r\n\r\nFollow me or tweet at me on Twitter: @joefeser.\r\n\r\n##Building \r\n\r\nUse ClickToBuild.bat to build.  You will need to have the Azure SDK 1.5 installed in order to build.\r\n\r\n##Nuget Packages\r\n\r\nIf you don't use an IoC container in your application or you are happy to use Autofac, download the default Nuget package:\r\n\r\n* ProjectExtensions.Azure.ServiceBus\r\n\r\nIf you want to use a specific IoC container, grab our core package:\r\n\r\n* ProjectExtensions.Azure.ServiceBus.Core\r\n\r\nYou can then either implement IAzureBusContainer for your IoC of choice or grab one of the pre-built options:\r\n\r\n* Autofac in ProjectExtensions.Azure.ServiceBus.IOC.Autofac\r\n* Castle Windsor in ProjectExtensions.Azure.ServiceBus.IOC.CastleWindsor\r\n* Ninject in ProjectExtensions.Azure.ServiceBus.IOC.Ninject\r\n* StructureMap in ProjectExtensions.Azure.ServiceBus.IOC.StructureMap\r\n* Unity in ProjectExtensions.Azure.ServiceBus.IOC.Unity\r\n\r\nIf you have a favorite IoC container we don't support, let us know, or, better yet, contribute an implementation.\r\n\r\n##Getting started\r\n\r\n1. Create a console application\r\n2. Using NuGet, install the package ProjectExtensions.Azure.ServiceBus.\r\n3. Optionally Add a reference to NLog\r\n4. Create a Message Class that you wish to handle:\r\n\r\n```csharp\r\npublic class TestMessage {\r\n  \r\n    public string MessageId {\r\n        get;\r\n        set;\r\n    }\r\n\r\n    public int Value {\r\n        get;\r\n        set;\r\n    }\r\n}\r\n```\r\n\r\n5\\. Create a Handler that will receive notifications when the message is placed on the bus. The custom attribute is optional but configures the Service Bus Subscription:\r\n\r\n```csharp\r\n[MessageHandlerConfiguration(\r\n    DefaultMessageTimeToLive = 240, //Time in minutes before your message is deleted from the subscription if you don't receive it.\r\n    LockDuration = 120, //Time that you wish to lock the message before it is marked to be received by another subscriber.\r\n    MaxRetries = 2, //Number of times to retry calling your handler before the message is deleted or placed in the DeadLetterAfterMaxRetries if configured.\r\n    PrefetchCount = 10, //Number of messages to pre-fetch. Used for high throughput \r\n    ReceiveMode = ReceiveMode.PeekLock, //PeekLock or Receive and Delete\r\n    Singleton = true)] //If it is a singleton, the instance will be created once, otherwise it will be created for each message received. Recommended to set to true.\r\npublic class TestMessageSubscriber : IHandleMessages<TestMessage> {\r\n\r\n    static Logger logger = LogManager.GetCurrentClassLogger();\r\n\r\n    public void Handle(IReceivedMessage<TestMessage> message) {\r\n        logger.Log(LogLevel.Info, \"Message received: {0} {1}\", message.Message.Value, message.Message.MessageId);\r\n    }\r\n}\r\n```\r\n\r\n6\\. Place initialization code at the beginning of your method or in your BootStrapper.  You will need a couple of using declarations:\r\n\r\n```csharp\r\nusing ProjectExtensions.Azure.ServiceBus;\r\nusing ProjectExtensions.Azure.ServiceBus.Autofac.Container;\r\n```\r\n\r\nBasic setup code (assuming you want to put Azure configuration information in your application configuration file):\r\n\r\n```csharp\r\nProjectExtensions.Azure.ServiceBus.BusConfiguration.WithSettings()\r\n    .UseAutofacContainer()\r\n    .ReadFromConfigFile()\r\n    .ServiceBusApplicationId(\"AppName\") //Multiple applications can be used in the same service bus namespace. It is converted to lower case.\r\n    .RegisterAssembly(typeof(TestMessageSubscriber).Assembly)\r\n    .Configure();\r\n```\r\n\r\nAnd configuration:\r\n\r\n```xml\r\n<add key=\"ServiceBusIssuerKey\" value=\"base64hash\" />\r\n<add key=\"ServiceBusIssuerName\" value=\"owner\" />\r\n<!--https://addresshere.servicebus.windows.net/-->\r\n<add key=\"ServiceBusNamespace\" value=\"namespace set up in service bus (addresshere) portion\" />\r\n```\r\n\r\nOtherwise, you can configure everything in code:\r\n\r\n```csharp\r\nProjectExtensions.Azure.ServiceBus.BusConfiguration.WithSettings()\r\n    .UseAutofacContainer()\r\n    .ServiceBusApplicationId(\"AppName\")\r\n    .ServiceBusIssuerKey(\"[sb password]\")\r\n    .ServiceBusIssuerName(\"owner\")\r\n    .ServiceBusNamespace(\"[addresshere]\")\r\n    .RegisterAssembly(typeof(TestMessageSubscriber).Assembly)\r\n    .Configure();\r\n```\r\n\r\n7\\. Put some messages on the Bus:\r\n\r\n```csharp\r\n//Blocking (Synchronous calls)\r\nfor (int i = 0; i < 20; i++) {\r\n    var message1 = new TestMessage() {\r\n        Value = i,\r\n        MessageId = DateTime.Now.ToString()\r\n    };\r\n    BusConfiguration.Instance.Bus.Publish(message1, null); //Optional Dictionary of name value pairs to pass with the massage. Can be used for filtering\r\n}\r\n\r\n//Async calls\r\nfor (int i = 0; i < 20; i++) {\r\n    var message1 = new TestMessage() {\r\n        Value = i,\r\n        MessageId = DateTime.Now.ToString()\r\n    };\r\n    BusConfiguration.Instance.Bus.PublishAsync(message2, (result) => {\r\n        if (!result.IsSuccess) { \r\n            //message failed. Handle it\r\n        }\r\n        Debug.WriteLine(\"async:\" + result.TimeSpent);\r\n    }, null); //Optional Dictionary of name value pairs to pass with the massage. Can be used for filtering\r\n}\r\n\r\n```\r\n\r\nWatch your method get called.\r\n\r\nWelcome to Azure Service Bus.\r\n\r\n##Using an IoC Conatiner Other Than Autofac\r\n\r\nUnless otherwise noted, everything works as shown in the getting starting section above.  This section outlines the things you will need to do differently.\r\n\r\n1. Install the Nuget packages ProjectExtensions.Azure.ServiceBus.Core and your specific IoC container (e.g. ProjectExtensions.Azure.ServiceBus.IOC.CastleWindsor for Castle Windsor) \r\ninstead of ProjectExtensions.Azure.ServiceBus\r\n2. Use the following initialization code at the beginning of your method or in your BootStrapper.  _The code examples shown below are for Castle Windsor.  Code for other containers follows the same pattern._\r\n\r\nYou will need a couple of using declarations:\r\n\r\n```csharp\r\nusing ProjectExtensions.Azure.ServiceBus;\r\nusing ProjectExtensions.Azure.ServiceBus.CastleWindsor.Container;\r\n```\r\n\r\nBasic setup code (assuming you want to put Azure configuration information in your application configuration file):\r\n\r\n```csharp\r\nProjectExtensions.Azure.ServiceBus.BusConfiguration.WithSettings()\r\n    .UseCastleWindsorContainer()\r\n    .ReadFromConfigFile()\r\n    .ServiceBusApplicationId(\"AppName\")\r\n    .RegisterAssembly(typeof(TestMessageSubscriber).Assembly)\r\n    .Configure();\r\n```\r\n\r\nOtherwise, you can configure everything in code:\r\n\r\n```csharp\r\nProjectExtensions.Azure.ServiceBus.BusConfiguration.WithSettings()\r\n    .UseCastleWindsorContainer()\r\n    .ServiceBusApplicationId(\"AppName\")\r\n    .ServiceBusIssuerKey(\"[sb password]\")\r\n    .ServiceBusIssuerName(\"owner\")\r\n    .ServiceBusNamespace(\"[addresshere]\")\r\n    .RegisterAssembly(typeof(TestMessageSubscriber).Assembly)\r\n    .Configure();\r\n```\r\n\r\nYou may also download the repository and check out the Samples in the /src/samples folder.\r\n\r\nThe Sample used to build this document can be found in the PubSubUsingConfiguration example.\r\n\r\nClick on the \"Zip\" Icon at the top of the page to download the latest source code.\r\n\r\n##Release Notes\r\n\r\n###Version 0.9.0\r\n\r\n* Allow support for other IoC containers to be added. Continue to support Autofac.\r\n* Support for Castle Windsor IoC.\r\n* Support for Ninject IoC.\r\n* Support for StructureMap IoC.\r\n* Support for Unity IoC.\r\n* BREAKING CHANGE. Move Autofac support into seperate DLL. Existing implementations need to add a reference to ProjectExtensions.Azure.ServiceBus.Autofac and change initialization code as shown in the getting started example.\r\n* BREAKING CHANGE. WithSettings No longer accepts the AutoFac Container as a parameter. This change was made to support the other containers.\r\n* BREAKING CHANGE. You must add .UseAutofacContainer() after WithSettings(). If you wich to use your existing container, You would pass it into this method call.\r\n\r\n###Version 0.9.1\r\n\r\n* Fixed bug in AutoFac registration of a Default Serializer.\r\n* Fixed bug in AutoFac registration of a any items internally registered on the default container.\r\n* Fixed bug in Publish method that ignored the serializer passed in and defaulted back to default serializer.\r\n\r\n###Version 0.9.2\r\n\r\n* Added self healing of deleted topic during application execution. Error is still thrown since no subscribers will exist.\r\n* Added self healing of deleted subscriptions during application execution. Any messages sent to the topic while your client subscription is deleted will not be received. The sender does not understand how many receivers exist and therefor does not know that the message needs to be resent.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}